# v0.9.0 Refactoring Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Address GitHub issues #86-100 through systematic refactoring, bug fixes, and code quality improvements.

**Architecture:** Refactor the Agent interface to return a structured result type instead of io.Reader, extract common execution logic, fix parser error handling, and add defensive improvements throughout.

**Tech Stack:** Go 1.21+, standard library (no new dependencies)

---

## Issue Priority Summary

| Priority | Issues |
|----------|--------|
| Critical | #86 (leaky io.Reader), #87 (parser loses findings) |
| High | #88 (nil pointer panic), #89 (agent duplication) |
| Medium | #91 (ignored Close errors), #92 (inconsistent error handling), #93 (integration tests) |
| Low | #94-100 (code quality, docs, cleanup) |

---

## Task 1: Fix Parser Error Handling (#87)

**Files:**
- Modify: `internal/runner/runner.go:238-262`
- Modify: `internal/agent/parser.go` (add recoverable error type)
- Test: `internal/runner/runner_test.go`

**Step 1: Write failing test for parser error recovery**

```go
// internal/runner/runner_test.go
func TestRunReviewer_ParserErrorRecovery(t *testing.T) {
    // Create mock agent that returns JSONL with one bad line in the middle
    mockAgent := &mockStreamingAgent{
        output: `{"text":"finding 1","file":"a.go","line":1}
invalid json line here
{"text":"finding 2","file":"b.go","line":2}`,
    }

    r := &Runner{
        config:    Config{Reviewers: 1, Timeout: 10 * time.Second},
        agents:    []agent.Agent{mockAgent},
        logger:    terminal.NewLogger(false),
        completed: &atomic.Int32{},
    }

    result := r.runReviewer(context.Background(), 1)

    // Should have 2 findings despite 1 parse error
    if len(result.Findings) != 2 {
        t.Errorf("expected 2 findings, got %d", len(result.Findings))
    }
    if result.ParseErrors != 1 {
        t.Errorf("expected 1 parse error, got %d", result.ParseErrors)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/runner -run TestRunReviewer_ParserErrorRecovery -v`
Expected: FAIL (test file or mock doesn't exist yet, or findings != 2)

**Step 3: Add RecoverableParseError type**

```go
// internal/agent/parser.go - add after existing types

// RecoverableParseError indicates a parse error that allows continued parsing.
// The scanner can continue to the next line/item.
type RecoverableParseError struct {
    Line    int
    Message string
}

func (e *RecoverableParseError) Error() string {
    return fmt.Sprintf("parse error at line %d: %s", e.Line, e.Message)
}

// IsRecoverable returns true if err is a RecoverableParseError.
func IsRecoverable(err error) bool {
    var rpe *RecoverableParseError
    return errors.As(err, &rpe)
}
```

**Step 4: Update Codex parser to return recoverable errors**

```go
// internal/agent/codex_review_parser.go - update ReadFinding method
// Change the JSON unmarshal error handling:

if err := json.Unmarshal([]byte(line), &event); err != nil {
    p.parseErrors++
    return nil, &RecoverableParseError{
        Line:    p.lineNum,
        Message: fmt.Sprintf("invalid JSON: %v", err),
    }
}
```

**Step 5: Update runner to continue on recoverable errors**

```go
// internal/runner/runner.go - replace lines 238-262

finding, err := parser.ReadFinding(scanner)
if err != nil {
    result.ParseErrors++
    if agent.IsRecoverable(err) {
        // Log and continue parsing
        if r.verbose() {
            r.logger.Logf(terminal.StyleWarning, "Reviewer #%d: %v", reviewerID, err)
        }
        continue
    }
    // Fatal error - break to avoid infinite loop
    break
}
```

**Step 6: Run test to verify it passes**

Run: `go test ./internal/runner -run TestRunReviewer_ParserErrorRecovery -v`
Expected: PASS

**Step 7: Run full test suite**

Run: `make test`
Expected: All tests pass

**Step 8: Commit**

```bash
git add internal/agent/parser.go internal/agent/codex_review_parser.go internal/runner/runner.go internal/runner/runner_test.go
git commit -m "fix: continue parsing after recoverable errors (#87)

Parser errors no longer discard remaining findings. Recoverable
errors (malformed JSON lines) are logged and parsing continues.
Fatal errors still break the loop to prevent infinite loops."
```

---

## Task 2: Fix Nil Pointer Panic in cmdReader.Close (#88)

**Files:**
- Modify: `internal/agent/cmd_reader.go:32-55`
- Test: `internal/agent/cmd_reader_test.go`

**Step 1: Write failing test for edge case**

```go
// internal/agent/cmd_reader_test.go - add test
func TestCmdReader_CloseWithNilProcess(t *testing.T) {
    // cmdReader with cmd set but Process is nil (Start() was never called)
    cmd := exec.Command("true") // Don't start it

    reader := &cmdReader{
        Reader: strings.NewReader(""),
        cmd:    cmd,
        ctx:    context.Background(),
    }

    // Should not panic
    err := reader.Close()
    if err != nil {
        t.Errorf("unexpected error: %v", err)
    }
}

func TestCmdReader_CloseWithContextCancel(t *testing.T) {
    ctx, cancel := context.WithCancel(context.Background())
    cancel() // Cancel immediately

    // Create a long-running command
    cmd := exec.CommandContext(ctx, "sleep", "10")
    cmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}

    stdout, _ := cmd.StdoutPipe()
    _ = cmd.Start()

    reader := &cmdReader{
        Reader: stdout,
        cmd:    cmd,
        ctx:    ctx,
    }

    // Should kill process group and not panic
    err := reader.Close()
    if err != nil {
        t.Errorf("unexpected error: %v", err)
    }
}
```

**Step 2: Run test to verify behavior**

Run: `go test ./internal/agent -run TestCmdReader_Close -v`
Expected: Tests pass (current code already handles nil Process)

**Step 3: Add defensive PID capture**

```go
// internal/agent/cmd_reader.go - update Close() method

func (r *cmdReader) Close() error {
    r.closeOnce.Do(func() {
        // Close the reader if it implements io.Closer
        if closer, ok := r.Reader.(io.Closer); ok {
            _ = closer.Close()
        }

        // Kill the process group if context was canceled or timed out
        if r.cmd != nil && r.cmd.Process != nil {
            // Capture PID before any state changes
            pid := r.cmd.Process.Pid

            if r.ctx != nil && r.ctx.Err() != nil {
                // Kill the entire process group (negative PID)
                // Ignore errors - process may have already exited
                _ = syscall.Kill(-pid, syscall.SIGKILL)
            }

            // Wait for command to complete and capture exit code
            err := r.cmd.Wait()
            if err != nil {
                if exitErr, ok := err.(*exec.ExitError); ok {
                    r.exitCode = exitErr.ExitCode()
                } else {
                    r.exitCode = -1
                }
            }
        }

        // Clean up temp file if one was created (ref-file pattern)
        CleanupTempFile(r.tempFilePath)
    })

    return nil
}
```

**Step 4: Run tests**

Run: `go test ./internal/agent -run TestCmdReader -v`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/agent/cmd_reader.go internal/agent/cmd_reader_test.go
git commit -m "fix: capture PID before process group kill (#88)

Defensively capture PID before calling syscall.Kill to prevent
any theoretical race condition. Added tests for edge cases."
```

---

## Task 3: Replace io.Reader with Structured ExecutionResult (#86)

**Files:**
- Create: `internal/agent/result.go`
- Modify: `internal/agent/agent.go`
- Modify: `internal/agent/cmd_reader.go`
- Modify: `internal/agent/codex.go`
- Modify: `internal/agent/claude.go`
- Modify: `internal/agent/gemini.go`
- Modify: `internal/runner/runner.go`
- Modify: `internal/summarizer/summarizer.go`
- Modify: `internal/fpfilter/filter.go`
- Test: `internal/agent/result_test.go`

**Step 1: Write test for new ExecutionResult type**

```go
// internal/agent/result_test.go
package agent

import (
    "io"
    "strings"
    "testing"
)

func TestExecutionResult_Close(t *testing.T) {
    result := &ExecutionResult{
        reader:   io.NopCloser(strings.NewReader("test")),
        exitCode: 0,
        stderr:   "some stderr",
    }

    // Read all content
    content, err := io.ReadAll(result)
    if err != nil {
        t.Fatalf("unexpected read error: %v", err)
    }
    if string(content) != "test" {
        t.Errorf("expected 'test', got '%s'", content)
    }

    // Close
    if err := result.Close(); err != nil {
        t.Fatalf("unexpected close error: %v", err)
    }

    // Check exit code and stderr after close
    if result.ExitCode() != 0 {
        t.Errorf("expected exit code 0, got %d", result.ExitCode())
    }
    if result.Stderr() != "some stderr" {
        t.Errorf("expected stderr 'some stderr', got '%s'", result.Stderr())
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/agent -run TestExecutionResult -v`
Expected: FAIL (type doesn't exist)

**Step 3: Create ExecutionResult type**

```go
// internal/agent/result.go
package agent

import (
    "io"
    "sync"
)

// ExecutionResult wraps command execution output with lifecycle management.
// It implements io.ReadCloser and provides access to exit code and stderr
// after Close() is called.
//
// This type replaces the previous pattern of returning io.Reader and requiring
// callers to type-assert for ExitCoder and StderrProvider interfaces.
type ExecutionResult struct {
    reader       io.ReadCloser
    exitCode     int
    exitCodeFunc func() int    // called on Close to get final exit code
    stderr       string
    stderrFunc   func() string // called on Close to get stderr
    closeOnce    sync.Once
    closed       bool
}

// NewExecutionResult creates a new ExecutionResult wrapping the given reader.
// The exitCodeFunc and stderrFunc are called during Close() to retrieve
// final values.
func NewExecutionResult(reader io.ReadCloser, exitCodeFunc func() int, stderrFunc func() string) *ExecutionResult {
    return &ExecutionResult{
        reader:       reader,
        exitCodeFunc: exitCodeFunc,
        stderrFunc:   stderrFunc,
    }
}

// Read implements io.Reader.
func (r *ExecutionResult) Read(p []byte) (n int, err error) {
    return r.reader.Read(p)
}

// Close implements io.Closer. After Close returns, ExitCode() and Stderr()
// return valid values.
func (r *ExecutionResult) Close() error {
    var closeErr error
    r.closeOnce.Do(func() {
        closeErr = r.reader.Close()
        if r.exitCodeFunc != nil {
            r.exitCode = r.exitCodeFunc()
        }
        if r.stderrFunc != nil {
            r.stderr = r.stderrFunc()
        }
        r.closed = true
    })
    return closeErr
}

// ExitCode returns the process exit code. Only valid after Close().
func (r *ExecutionResult) ExitCode() int {
    return r.exitCode
}

// Stderr returns captured stderr output. Only valid after Close().
func (r *ExecutionResult) Stderr() string {
    return r.stderr
}

// IsClosed returns true if Close() has been called.
func (r *ExecutionResult) IsClosed() bool {
    return r.closed
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/agent -run TestExecutionResult -v`
Expected: PASS

**Step 5: Update Agent interface**

```go
// internal/agent/agent.go - replace entire file

package agent

import (
    "context"
)

// Agent represents a backend that can execute code reviews and summarizations.
// Implementations include CodexAgent, ClaudeAgent, GeminiAgent.
type Agent interface {
    // Name returns the agent's identifier (e.g., "codex", "claude", "gemini").
    Name() string

    // IsAvailable checks if the agent's backend CLI is installed and accessible.
    // Returns an error if the agent cannot be used.
    IsAvailable() error

    // ExecuteReview runs a code review with the given configuration.
    // Returns an ExecutionResult for streaming output.
    // The caller MUST call Close() on the result to clean up resources.
    ExecuteReview(ctx context.Context, config *ReviewConfig) (*ExecutionResult, error)

    // ExecuteSummary runs a summarization task with the given prompt and input data.
    // The prompt contains the summarization instructions.
    // The input contains the data to summarize (typically JSON-encoded aggregated findings).
    // Returns an ExecutionResult for the output.
    // The caller MUST call Close() on the result to clean up resources.
    ExecuteSummary(ctx context.Context, prompt string, input []byte) (*ExecutionResult, error)
}
```

**Step 6: Update cmdReader to support ExecutionResult**

```go
// internal/agent/cmd_reader.go - add method

// ToExecutionResult converts cmdReader to an ExecutionResult.
// This is a transitional method - cmdReader will be internal to ExecutionResult.
func (r *cmdReader) ToExecutionResult() *ExecutionResult {
    return NewExecutionResult(
        r,
        func() int { return r.ExitCode() },
        func() string { return r.Stderr() },
    )
}
```

**Step 7: Update CodexAgent**

```go
// internal/agent/codex.go - update return types

// ExecuteReview signature change
func (c *CodexAgent) ExecuteReview(ctx context.Context, config *ReviewConfig) (*ExecutionResult, error) {
    // ... existing code until return statement ...

    // Replace:
    // return &cmdReader{...}, nil
    // With:
    cmdReader := &cmdReader{
        Reader:       stdout,
        cmd:          cmd,
        ctx:          ctx,
        stderr:       stderr,
        tempFilePath: tempFilePath,
    }
    return cmdReader.ToExecutionResult(), nil
}

// ExecuteSummary signature change
func (c *CodexAgent) ExecuteSummary(ctx context.Context, prompt string, input []byte) (*ExecutionResult, error) {
    // ... existing code until return statement ...

    cmdReader := &cmdReader{
        Reader: stdout,
        cmd:    cmd,
        ctx:    ctx,
        stderr: stderr,
    }
    return cmdReader.ToExecutionResult(), nil
}
```

**Step 8: Update ClaudeAgent (same pattern as CodexAgent)**

```go
// internal/agent/claude.go - update both ExecuteReview and ExecuteSummary
// Same pattern: change return type and use cmdReader.ToExecutionResult()
```

**Step 9: Update GeminiAgent (same pattern)**

**Step 10: Update runner to use ExecutionResult**

```go
// internal/runner/runner.go - update runReviewer method

// Replace lines 196-212 with:
result, err := selectedAgent.ExecuteReview(timeoutCtx, reviewConfig)
if err != nil {
    result.ExitCode = -1
    result.Duration = time.Since(start)
    return result
}
defer result.Close()

// ... parsing code stays the same ...

// Replace closeReader() usage with just using result directly:
// Old: exitCode := closeReader()
// New: exitCode := result.ExitCode()
```

**Step 11: Update summarizer**

```go
// internal/summarizer/summarizer.go - update to use ExecutionResult
// Simplify close/exit code handling
```

**Step 12: Update fpfilter**

```go
// internal/fpfilter/filter.go - update to use ExecutionResult
```

**Step 13: Run full test suite**

Run: `make test`
Expected: All tests pass

**Step 14: Commit**

```bash
git add internal/agent/*.go internal/runner/runner.go internal/summarizer/summarizer.go internal/fpfilter/filter.go
git commit -m "refactor: replace io.Reader with ExecutionResult type (#86)

ExecutionResult provides a guaranteed cleanup API:
- Implements io.ReadCloser for streaming
- ExitCode() and Stderr() available after Close()
- No more type assertions at call sites
- Compile-time enforcement of proper resource cleanup"
```

---

## Task 4: Extract Common Agent Execution Logic (#89)

**Files:**
- Create: `internal/agent/executor.go`
- Modify: `internal/agent/codex.go`
- Modify: `internal/agent/claude.go`
- Modify: `internal/agent/gemini.go`
- Test: `internal/agent/executor_test.go`

**Step 1: Write test for executor helper**

```go
// internal/agent/executor_test.go
package agent

import (
    "bytes"
    "context"
    "io"
    "testing"
)

func TestExecuteCommand(t *testing.T) {
    ctx := context.Background()

    result, err := executeCommand(ctx, executeOptions{
        Command: "echo",
        Args:    []string{"hello"},
        WorkDir: "",
    })
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    defer result.Close()

    output, _ := io.ReadAll(result)
    if !bytes.Contains(output, []byte("hello")) {
        t.Errorf("expected output to contain 'hello', got: %s", output)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/agent -run TestExecuteCommand -v`
Expected: FAIL (function doesn't exist)

**Step 3: Create executor helper**

```go
// internal/agent/executor.go
package agent

import (
    "bytes"
    "context"
    "fmt"
    "io"
    "os/exec"
    "syscall"
)

// executeOptions configures command execution.
type executeOptions struct {
    Command      string
    Args         []string
    Stdin        io.Reader
    WorkDir      string
    TempFilePath string // temp file to clean up on Close
}

// executeCommand runs a command with proper process group setup and resource management.
// This is the shared implementation used by all agent ExecuteReview/ExecuteSummary methods.
func executeCommand(ctx context.Context, opts executeOptions) (*ExecutionResult, error) {
    cmd := exec.CommandContext(ctx, opts.Command, opts.Args...)

    if opts.Stdin != nil {
        cmd.Stdin = opts.Stdin
    }

    if opts.WorkDir != "" {
        cmd.Dir = opts.WorkDir
    }

    // Set process group for proper signal handling
    cmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}

    // Capture stderr for error diagnostics
    stderr := &bytes.Buffer{}
    cmd.Stderr = stderr

    stdout, err := cmd.StdoutPipe()
    if err != nil {
        CleanupTempFile(opts.TempFilePath)
        return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
    }

    if err := cmd.Start(); err != nil {
        CleanupTempFile(opts.TempFilePath)
        return nil, fmt.Errorf("failed to start %s: %w", opts.Command, err)
    }

    reader := &cmdReader{
        Reader:       stdout,
        cmd:          cmd,
        ctx:          ctx,
        stderr:       stderr,
        tempFilePath: opts.TempFilePath,
    }

    return reader.ToExecutionResult(), nil
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/agent -run TestExecuteCommand -v`
Expected: PASS

**Step 5: Refactor CodexAgent to use executeCommand**

```go
// internal/agent/codex.go - simplify ExecuteReview

func (c *CodexAgent) ExecuteReview(ctx context.Context, config *ReviewConfig) (*ExecutionResult, error) {
    if err := c.IsAvailable(); err != nil {
        return nil, err
    }

    var stdin io.Reader
    var tempFilePath string
    var args []string

    if config.CustomPrompt != "" {
        diff, err := GetGitDiff(ctx, config.BaseRef, config.WorkDir)
        if err != nil {
            return nil, fmt.Errorf("failed to get diff for review: %w", err)
        }

        useRefFile := config.UseRefFile || len(diff) > RefFileSizeThreshold

        var prompt string
        if useRefFile && diff != "" {
            absPath, err := WriteDiffToTempFile(config.WorkDir, diff)
            if err != nil {
                return nil, err
            }
            tempFilePath = absPath
            prompt = BuildCodexRefFilePrompt(config.CustomPrompt, absPath)
        } else {
            prompt = BuildPromptWithDiff(config.CustomPrompt, diff)
        }

        args = []string{"exec", "--json", "--color", "never", "-"}
        stdin = bytes.NewReader([]byte(prompt))
    } else {
        if config.UseRefFile {
            fmt.Fprintln(os.Stderr, "Note: --ref-file flag has no effect in Codex default mode (requires custom prompt)")
        }
        args = []string{"exec", "--json", "--color", "never", "review", "--base", config.BaseRef}
    }

    return executeCommand(ctx, executeOptions{
        Command:      "codex",
        Args:         args,
        Stdin:        stdin,
        WorkDir:      config.WorkDir,
        TempFilePath: tempFilePath,
    })
}
```

**Step 6: Refactor ClaudeAgent similarly**

**Step 7: Refactor GeminiAgent similarly**

**Step 8: Run full test suite**

Run: `make test`
Expected: All tests pass

**Step 9: Commit**

```bash
git add internal/agent/executor.go internal/agent/executor_test.go internal/agent/codex.go internal/agent/claude.go internal/agent/gemini.go
git commit -m "refactor: extract common executeCommand helper (#89)

Reduces ~70 lines of duplicated code across agent implementations.
Each agent now only implements:
- CLI-specific argument construction
- Prompt formatting

Common logic (process groups, stderr capture, pipes, cleanup) is
now in one place."
```

---

## Task 5: Add Compile-Time Interface Checks (#96)

**Files:**
- Modify: `internal/agent/codex.go`
- Modify: `internal/agent/claude.go`
- Modify: `internal/agent/gemini.go`
- Modify: `internal/agent/cmd_reader.go`

**Step 1: Add interface assertions**

```go
// internal/agent/codex.go - add at top of file after imports
var _ Agent = (*CodexAgent)(nil)

// internal/agent/claude.go
var _ Agent = (*ClaudeAgent)(nil)

// internal/agent/gemini.go
var _ Agent = (*GeminiAgent)(nil)

// internal/agent/cmd_reader.go
var (
    _ io.Closer = (*cmdReader)(nil)
)
```

**Step 2: Verify compilation**

Run: `go build ./...`
Expected: Compiles successfully

**Step 3: Commit**

```bash
git add internal/agent/codex.go internal/agent/claude.go internal/agent/gemini.go internal/agent/cmd_reader.go
git commit -m "chore: add compile-time interface compliance checks (#96)

Ensures Agent implementations stay in sync with interface changes.
Catches signature mismatches at compile time instead of runtime."
```

---

## Task 6: Log Close Errors (#91)

**Files:**
- Modify: `internal/runner/runner.go`
- Modify: `internal/summarizer/summarizer.go`
- Modify: `internal/fpfilter/filter.go`

**Step 1: Update runner (already uses ExecutionResult, just add logging)**

```go
// internal/runner/runner.go - in runReviewer, after parsing loop

if err := result.Close(); err != nil {
    if r.verbose() {
        r.logger.Logf(terminal.StyleWarning, "Reviewer #%d close error (non-fatal): %v", reviewerID, err)
    }
}
exitCode := result.ExitCode()
```

**Step 2: Update summarizer similarly**

**Step 3: Update fpfilter similarly**

**Step 4: Run tests**

Run: `make test`
Expected: All tests pass

**Step 5: Commit**

```bash
git add internal/runner/runner.go internal/summarizer/summarizer.go internal/fpfilter/filter.go
git commit -m "fix: log Close() errors instead of silently ignoring (#91)

Close errors are now logged at verbose/debug level. This aids
debugging without failing the operation on cleanup issues."
```

---

## Task 7: Clean Up Dead Code (#99)

**Files:**
- Modify: `internal/runner/report.go`
- Modify: `internal/runner/report_test.go`

**Step 1: Check if joinInts is used**

Run: `grep -r "joinInts" internal/`

**Step 2: Move to test file or remove**

If only used in tests, move the function definition to the test file.
If not used at all, remove it entirely.

**Step 3: Run tests**

Run: `make test`
Expected: All tests pass

**Step 4: Commit**

```bash
git add internal/runner/report.go internal/runner/report_test.go
git commit -m "chore: remove unused joinInts function (#99)

Function was defined but never called in production code."
```

---

## Task 8: Rename github_actions.go (#98)

**Files:**
- Rename: `cmd/acr/github_actions.go` -> `cmd/acr/pr_submit.go`

**Step 1: Rename file**

```bash
git mv cmd/acr/github_actions.go cmd/acr/pr_submit.go
```

**Step 2: Verify build**

Run: `go build ./cmd/acr`
Expected: Compiles successfully

**Step 3: Commit**

```bash
git add cmd/acr/
git commit -m "refactor: rename github_actions.go to pr_submit.go (#98)

Better reflects the file's actual purpose (PR submission workflow)
rather than suggesting GitHub Actions CI integration."
```

---

## Task 9: Extract Non-Finding Detection Logic (#100)

**Files:**
- Create: `internal/agent/nonfinding.go`
- Modify: `internal/agent/claude_review_parser.go`
- Modify: `internal/agent/gemini_review_parser.go`
- Test: `internal/agent/nonfinding_test.go`

**Step 1: Write test for shared helper**

```go
// internal/agent/nonfinding_test.go
package agent

import "testing"

func TestIsNonFindingText(t *testing.T) {
    tests := []struct {
        text     string
        expected bool
    }{
        {"No issues found", true},
        {"Looks good to me!", true},
        {"Code looks clean", true},
        {"Review complete", true},
        {"Bug: missing null check", false},
        {"Error handling needed", false},
    }

    for _, tt := range tests {
        t.Run(tt.text, func(t *testing.T) {
            if got := IsNonFindingText(tt.text); got != tt.expected {
                t.Errorf("IsNonFindingText(%q) = %v, want %v", tt.text, got, tt.expected)
            }
        })
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./internal/agent -run TestIsNonFindingText -v`
Expected: FAIL (function doesn't exist)

**Step 3: Create shared helper**

```go
// internal/agent/nonfinding.go
package agent

import "strings"

// nonFindingPhrases are common phrases indicating "no issues found" responses
// rather than actual code review findings.
var nonFindingPhrases = []string{
    "no issues",
    "no findings",
    "no bugs",
    "no problems",
    "looks good",
    "code looks clean",
    "code looks correct",
    "review complete",
}

// IsNonFindingText returns true if text appears to be a "no issues found"
// response rather than an actual finding.
func IsNonFindingText(text string) bool {
    lower := strings.ToLower(text)
    for _, phrase := range nonFindingPhrases {
        if strings.Contains(lower, phrase) {
            return true
        }
    }
    return false
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./internal/agent -run TestIsNonFindingText -v`
Expected: PASS

**Step 5: Update Claude parser to use shared helper**

```go
// internal/agent/claude_review_parser.go - replace inline checks with:
if IsNonFindingText(line) {
    continue
}
```

**Step 6: Update Gemini parser similarly**

**Step 7: Run full test suite**

Run: `make test`
Expected: All tests pass

**Step 8: Commit**

```bash
git add internal/agent/nonfinding.go internal/agent/nonfinding_test.go internal/agent/claude_review_parser.go internal/agent/gemini_review_parser.go
git commit -m "refactor: extract shared non-finding detection logic (#100)

Single place to maintain the list of phrases that indicate
'no issues found' responses. Consistent behavior across parsers."
```

---

## Task 10: Document Magic Numbers (#94)

**Files:**
- Modify: `internal/agent/reffile.go`
- Modify: `internal/fpfilter/filter.go`
- Modify: `internal/runner/runner.go`

**Step 1: Add documentation comments**

```go
// internal/agent/reffile.go
// RefFileSizeThreshold is the diff size (in bytes) above which we write to a
// temp file instead of passing via stdin. This avoids ARG_MAX limits (~128KB
// on macOS) and keeps prompts manageable for LLM context windows.
// 100KB provides headroom below the limit while handling most typical diffs.
const RefFileSizeThreshold = 100 * 1024

// internal/fpfilter/filter.go
// DefaultThreshold is the minimum confidence score (0-100) for a finding to
// be considered a true positive. Findings below this threshold are filtered
// as likely false positives. 75 was chosen based on empirical testing to
// balance precision (fewer false positives) with recall (keeping real issues).
const DefaultThreshold = 75

// internal/runner/runner.go
// maxFindingPreviewLength is the maximum characters shown for a finding in
// verbose output. Longer findings are truncated with "..." to prevent
// excessive terminal output while preserving enough context for debugging.
const maxFindingPreviewLength = 120
```

**Step 2: Update code to use named constant**

```go
// internal/runner/runner.go line 254
if len(text) > maxFindingPreviewLength {
    text = text[:maxFindingPreviewLength] + "..."
}
```

**Step 3: Run tests**

Run: `make test`
Expected: All tests pass

**Step 4: Commit**

```bash
git add internal/agent/reffile.go internal/fpfilter/filter.go internal/runner/runner.go
git commit -m "docs: document magic numbers with rationale (#94)

Added explanatory comments for:
- RefFileSizeThreshold (100KB)
- DefaultThreshold (75)
- maxFindingPreviewLength (120 chars)"
```

---

## Task 11: Clarify Fetch Flag Interaction (#95)

**Files:**
- Modify: `cmd/acr/main.go`

**Step 1: Add explanatory comment**

```go
// cmd/acr/main.go - near fetch flag resolution

// noFetch exists for shell alias ergonomics where --fetch=false is awkward.
// Example: alias acr-nofetch='acr --no-fetch'
// When both flags are set (unlikely), noFetch takes precedence.
fetchValue := fetch && !noFetch
```

**Step 2: Run tests**

Run: `make test`
Expected: All tests pass

**Step 3: Commit**

```bash
git add cmd/acr/main.go
git commit -m "docs: clarify fetch/noFetch flag interaction (#95)

Added comment explaining why both flags exist (shell alias ergonomics)
and their precedence when both are set."
```

---

## Task 12: Final Verification

**Step 1: Run full quality checks**

Run: `make check`
Expected: All checks pass (fmt, lint, vet, staticcheck, tests)

**Step 2: Verify git status**

Run: `git log --oneline -15`

**Step 3: Create summary commit if needed**

If any loose ends, create a final cleanup commit.

---

## Deferred Tasks (Future Work)

The following issues require more extensive work and are deferred:

- **#90 (LGTM prompt)**: Feature addition requiring UX design decisions
- **#92 (Inconsistent error handling)**: Requires broader API review
- **#93 (Integration tests)**: Requires test infrastructure setup
- **#97 (Extract workspace package)**: Large refactor requiring separate planning

These should be addressed in subsequent releases.
